<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Modern Beat Frequency Generator</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background-color: #00008B; /* dark blue */
      overflow: hidden;
      height: 100%;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script>
    // Get canvas and context
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    // Declare center and radius variables
    let centerX, centerY, circleRadius;
    // Function to set canvas size and update circle metrics
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      centerX = canvas.width / 2;
      centerY = canvas.height / 2;
      circleRadius = Math.min(canvas.width, canvas.height) / 3;
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    // Allowed angle ranges (in degrees)
    let leftMinAngle = 135, leftMaxAngle = 225;
    let rightMinAngle = 315, rightMaxAngle = 405;

    // Initial frequencies mapping (400-480 Hz)
    // Defaults: left frequency 440 Hz, right frequency 445 Hz.
    let leftFrequency, rightFrequency;
    let leftAngle = leftMaxAngle - ((440 - 400) / 80) * 90; // 180°
    let rightAngle = rightMinAngle + ((445 - 400) / 80) * 90; // ≈365.625°

    function updateFrequencies() {
      // Left frequency increases as angle decreases.
      leftFrequency = 400 + ((leftMaxAngle - leftAngle) / 90) * 80;
      // Right frequency increases as angle increases.
      rightFrequency = 400 + ((rightAngle - rightMinAngle) / 90) * 80;
      if(audioStarted) {
        osc1.frequency.setValueAtTime(leftFrequency, audioCtx.currentTime);
        osc2.frequency.setValueAtTime(rightFrequency, audioCtx.currentTime);
      }
    }
    updateFrequencies();

    // Audio context and oscillators
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let osc1 = audioCtx.createOscillator();
    let osc2 = audioCtx.createOscillator();
    osc1.type = 'sine';
    osc2.type = 'sine';
    osc1.connect(audioCtx.destination);
    osc2.connect(audioCtx.destination);
    let audioStarted = false;

    // Dragging variables
    let dragging = false;
    let dragHandle = null; // "left" or "right"

    // Utility: convert degrees to radians
    function toRadians(deg) {
      return deg * Math.PI / 180;
    }

    // Return Cartesian coordinates on the circle for given angle
    function pointOnCircle(angleDeg) {
      const angleRad = toRadians(angleDeg);
      const x = centerX + circleRadius * Math.cos(angleRad);
      const y = centerY + circleRadius * Math.sin(angleRad);
      return { x, y };
    }

    // Check if point (mx, my) is near a given handle position
    function isNearHandle(mx, my, handlePos) {
      const dx = mx - handlePos.x;
      const dy = my - handlePos.y;
      return Math.sqrt(dx * dx + dy * dy) < 15;
    }

    // Mouse events on the canvas
    canvas.addEventListener("mousedown", (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      if (!audioStarted) {
        osc1.start();
        osc2.start();
        audioStarted = true;
      }

      const leftPos = pointOnCircle(leftAngle);
      const rightDisplayAngle = rightAngle >= 360 ? rightAngle - 360 : rightAngle;
      const rightPos = pointOnCircle(rightDisplayAngle);

      if(isNearHandle(mx, my, leftPos)) {
        dragging = true;
        dragHandle = "left";
      } else if(isNearHandle(mx, my, rightPos)) {
        dragging = true;
        dragHandle = "right";
      }
    });

    canvas.addEventListener("mousemove", (e) => {
      if (!dragging) return;

      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      let angle = Math.atan2(my - centerY, mx - centerX) * 180 / Math.PI;
      if(angle < 0) angle += 360;

      if(dragHandle === "left") {
        if(angle < leftMinAngle) angle = leftMinAngle;
        if(angle > leftMaxAngle) angle = leftMaxAngle;
        leftAngle = angle;
      } else if(dragHandle === "right") {
        let effectiveAngle = angle;
        if(effectiveAngle < rightMinAngle) effectiveAngle += 360;
        if(effectiveAngle < rightMinAngle) effectiveAngle = rightMinAngle;
        if(effectiveAngle > rightMaxAngle) effectiveAngle = rightMaxAngle;
        rightAngle = effectiveAngle;
      }
      updateFrequencies();
    });

    canvas.addEventListener("mouseup", () => {
      dragging = false;
      dragHandle = null;
    });
    canvas.addEventListener("mouseout", () => {
      dragging = false;
      dragHandle = null;
    });

    // Draw everything on the canvas
    function draw() {
      // Fill whole canvas with dark blue
      ctx.fillStyle = "#00008B";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw central white circle
      ctx.beginPath();
      ctx.arc(centerX, centerY, circleRadius, 0, Math.PI * 2);
      ctx.fillStyle = "#ffffff";
      ctx.fill();
      ctx.closePath();

      // Draw white circle border
      ctx.beginPath();
      ctx.arc(centerX, centerY, circleRadius, 0, Math.PI * 2);
      ctx.lineWidth = 4;
      ctx.strokeStyle = "#ffffff";
      ctx.stroke();
      ctx.closePath();

      // Draw left slider green arc along the edge
      ctx.beginPath();
      ctx.lineWidth = 6;
      ctx.strokeStyle = "#00FF00";
      ctx.arc(centerX, centerY, circleRadius, toRadians(leftAngle), toRadians(leftMaxAngle));
      ctx.stroke();
      ctx.closePath();

      // Draw right slider green arc along the edge
      const drawRightMin = toRadians(rightMinAngle);
      const drawRightAngle = toRadians(rightAngle >= 360 ? rightAngle - 360 : rightAngle);
      ctx.beginPath();
      ctx.lineWidth = 6;
      ctx.strokeStyle = "#00FF00";
      ctx.arc(centerX, centerY, circleRadius, drawRightMin, drawRightAngle);
      ctx.stroke();
      ctx.closePath();

      // Draw left handle
      const leftHandle = pointOnCircle(leftAngle);
      ctx.beginPath();
      ctx.arc(leftHandle.x, leftHandle.y, 10, 0, Math.PI * 2);
      ctx.fillStyle = dragHandle === "left" ? "#00FF00" : "#ffffff";
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "#00FF00";
      ctx.stroke();
      ctx.closePath();

      // Draw right handle
      const rightDisplayAngle = rightAngle >= 360 ? rightAngle - 360 : rightAngle;
      const rightHandle = pointOnCircle(rightDisplayAngle);
      ctx.beginPath();
      ctx.arc(rightHandle.x, rightHandle.y, 10, 0, Math.PI * 2);
      ctx.fillStyle = dragHandle === "right" ? "#00FF00" : "#ffffff";
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "#00FF00";
      ctx.stroke();
      ctx.closePath();

      // Draw frequency texts in the center
      ctx.fillStyle = "#000000";
      ctx.font = "bold 20px Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      const beatFrequency = Math.abs(leftFrequency - rightFrequency).toFixed(1);
      const lines = [
        "Freq1: " + leftFrequency.toFixed(1) + " Hz",
        "Freq2: " + rightFrequency.toFixed(1) + " Hz",
        "Beat: " + beatFrequency + " Hz"
      ];
      lines.forEach((line, index) => {
        ctx.fillText(line, centerX, centerY - 30 + index * 25);
      });

      requestAnimationFrame(draw);
    }
    draw();
  </script>
</body>
</html>
