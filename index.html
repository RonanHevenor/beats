<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Modern Beat Frequency Generator</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background-color: #00008B; /* dark blue background */
      overflow: hidden;
      height: 100%;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script>
    // Get canvas and context
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    // Global geometry variables
    let centerX, centerY, circleRadius;
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      centerX = canvas.width / 2;
      centerY = canvas.height / 2;
      circleRadius = Math.min(canvas.width, canvas.height) / 3;
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    // Allowed angle ranges (in degrees) for each slider
    // Left slider for frequency 1: allowed between 135° and 225°
    // Right slider for frequency 2: allowed between 315° and 405° (405 means 45° when normalized)
    const leftMinAngle = 135, leftMaxAngle = 225;
    const rightMinAngle = 315, rightMaxAngle = 405;

    // Initial slider positions
    // Mapping: frequency in [400,480] Hz maps onto a 90° arc.
    // Left: Freq1 = 400 at leftMaxAngle, 480 at leftMinAngle.
    // Right: Freq2 = 400 at rightMinAngle, 480 at rightMaxAngle.
    let leftAngle = leftMaxAngle - ((440 - 400) / 80) * (leftMaxAngle - leftMinAngle); // 180°
    let rightAngle = rightMinAngle + ((445 - 400) / 80) * (rightMaxAngle - rightMinAngle); // ≈365.625°

    let leftFrequency, rightFrequency;
    function updateFrequencies() {
      leftFrequency = 400 + ((leftMaxAngle - leftAngle) / (leftMaxAngle - leftMinAngle)) * 80;
      rightFrequency = 400 + ((rightAngle - rightMinAngle) / (rightMaxAngle - rightMinAngle)) * 80;
      if (audioStarted) {
        osc1.frequency.setValueAtTime(leftFrequency, audioCtx.currentTime);
        osc2.frequency.setValueAtTime(rightFrequency, audioCtx.currentTime);
      }
    }
    updateFrequencies();

    // Audio context and oscillators
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let osc1 = audioCtx.createOscillator();
    let osc2 = audioCtx.createOscillator();
    osc1.type = 'sine';
    osc2.type = 'sine';
    osc1.connect(audioCtx.destination);
    osc2.connect(audioCtx.destination);
    let audioStarted = false;

    // Draggable state variables
    let dragging = false;
    let dragHandle = null; // "left" or "right"

    // Utility: Convert degrees to radians
    function toRadians(deg) {
      return deg * Math.PI / 180;
    }

    // Given an angle (in degrees), compute the point on the circle's circumference.
    function pointOnCircle(angleDeg) {
      const angleRad = toRadians(angleDeg);
      return {
        x: centerX + circleRadius * Math.cos(angleRad),
        y: centerY + circleRadius * Math.sin(angleRad)
      };
    }

    // Determine if the mouse position (mx, my) is near a given handle (within 15px)
    function isNearHandle(mx, my, handlePos) {
      const dx = mx - handlePos.x;
      const dy = my - handlePos.y;
      return Math.sqrt(dx * dx + dy * dy) < 15;
    }

    // Mouse event handlers
    canvas.addEventListener("mousedown", (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      if (!audioStarted) {
        osc1.start();
        osc2.start();
        audioStarted = true;
      }

      const leftPos = pointOnCircle(leftAngle);
      const rightDisplayAngle = rightAngle >= 360 ? rightAngle - 360 : rightAngle;
      const rightPos = pointOnCircle(rightDisplayAngle);

      if (isNearHandle(mx, my, leftPos)) {
        dragging = true;
        dragHandle = "left";
      } else if (isNearHandle(mx, my, rightPos)) {
        dragging = true;
        dragHandle = "right";
      }
    });

    canvas.addEventListener("mousemove", (e) => {
      if (!dragging) return;
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      let angle = Math.atan2(my - centerY, mx - centerX) * 180 / Math.PI;
      if (angle < 0) angle += 360;

      if (dragHandle === "left") {
        // Constrain angle between leftMinAngle and leftMaxAngle.
        if (angle < leftMinAngle) angle = leftMinAngle;
        if (angle > leftMaxAngle) angle = leftMaxAngle;
        leftAngle = angle;
      } else if (dragHandle === "right") {
        // For right slider, adjust angle into the allowed range.
        let effectiveAngle = angle;
        if(effectiveAngle < rightMinAngle) effectiveAngle += 360;
        if (effectiveAngle < rightMinAngle) effectiveAngle = rightMinAngle;
        if (effectiveAngle > rightMaxAngle) effectiveAngle = rightMaxAngle;
        rightAngle = effectiveAngle;
      }
      updateFrequencies();
    });

    canvas.addEventListener("mouseup", () => {
      dragging = false;
      dragHandle = null;
    });
    canvas.addEventListener("mouseout", () => {
      dragging = false;
      dragHandle = null;
    });

    // Alternate drawing approach: render two slider tracks along the circle.
    function draw() {
      // Clear canvas with dark blue background.
      ctx.fillStyle = "#00008B";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw main white circle with a subtle shadow for depth.
      ctx.save();
      ctx.shadowColor = "rgba(0,0,0,0.4)";
      ctx.shadowBlur = 8;
      ctx.beginPath();
      ctx.arc(centerX, centerY, circleRadius, 0, Math.PI * 2);
      ctx.fillStyle = "#ffffff";
      ctx.fill();
      ctx.closePath();
      ctx.restore();

      // Draw a white border around the circle.
      ctx.beginPath();
      ctx.arc(centerX, centerY, circleRadius, 0, Math.PI * 2);
      ctx.lineWidth = 4;
      ctx.strokeStyle = "#ffffff";
      ctx.stroke();
      ctx.closePath();

      // Draw left slider track.
      // First, draw the base track as a light gray arc.
      ctx.beginPath();
      ctx.lineWidth = 8;
      ctx.strokeStyle = "#cccccc";
      ctx.arc(centerX, centerY, circleRadius, toRadians(leftMinAngle), toRadians(leftMaxAngle));
      ctx.stroke();
      ctx.closePath();

      // Then draw the active portion (green) from leftAngle to leftMaxAngle.
      ctx.beginPath();
      ctx.lineWidth = 8;
      ctx.strokeStyle = "#00FF00";
      ctx.arc(centerX, centerY, circleRadius, toRadians(leftAngle), toRadians(leftMaxAngle));
      ctx.stroke();
      ctx.closePath();

      // Draw the left slider handle.
      let leftHandle = pointOnCircle(leftAngle);
      ctx.beginPath();
      ctx.arc(leftHandle.x, leftHandle.y, 12, 0, Math.PI * 2);
      ctx.fillStyle = (dragHandle === "left") ? "#00FF00" : "#ffffff";
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "#00FF00";
      ctx.stroke();
      ctx.closePath();

      // Draw right slider track.
      // Base track.
      ctx.beginPath();
      ctx.lineWidth = 8;
      ctx.strokeStyle = "#cccccc";
      // Normalize angles: for drawing, convert rightMaxAngle if necessary.
      let normalizedRightMin = toRadians(rightMinAngle);
      let normalizedRightMax = toRadians(rightAngle >= 360 ? rightAngle - 360 : rightMaxAngle);
      ctx.arc(centerX, centerY, circleRadius, normalizedRightMin, normalizedRightMax);
      ctx.stroke();
      ctx.closePath();

      // Active portion from rightMinAngle to current rightAngle.
      ctx.beginPath();
      ctx.lineWidth = 8;
      ctx.strokeStyle = "#00FF00";
      let currentRightAngle = toRadians(rightAngle >= 360 ? rightAngle - 360 : rightAngle);
      ctx.arc(centerX, centerY, circleRadius, toRadians(rightMinAngle), currentRightAngle);
      ctx.stroke();
      ctx.closePath();

      // Draw the right slider handle.
      let rightDisplayAngle = rightAngle >= 360 ? rightAngle - 360 : rightAngle;
      let rightHandle = pointOnCircle(rightDisplayAngle);
      ctx.beginPath();
      ctx.arc(rightHandle.x, rightHandle.y, 12, 0, Math.PI * 2);
      ctx.fillStyle = (dragHandle === "right") ? "#00FF00" : "#ffffff";
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "#00FF00";
      ctx.stroke();
      ctx.closePath();

      // Draw frequency text in the center of the circle.
      ctx.fillStyle = "#000000";
      ctx.font = "bold 20px Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      const beatFrequency = Math.abs(leftFrequency - rightFrequency).toFixed(1);
      const lines = [
        "Freq1: " + leftFrequency.toFixed(1) + " Hz",
        "Freq2: " + rightFrequency.toFixed(1) + " Hz",
        "Beat: "  + beatFrequency + " Hz"
      ];
      lines.forEach((line, i) => {
        ctx.fillText(line, centerX, centerY - 30 + i * 25);
      });

      requestAnimationFrame(draw);
    }
    draw();
  </script>
</body>
</html>
