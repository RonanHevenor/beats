<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Modern Beat Frequency Generator</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background-color: #00008B; /* dark blue background */
      overflow: hidden;
      height: 100%;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script>
    // Get canvas and context
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    // Declare center and radius values
    let centerX, centerY, circleRadius;

    // Set canvas size and update circle metrics
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      centerX = canvas.width / 2;
      centerY = canvas.height / 2;
      circleRadius = Math.min(canvas.width, canvas.height) / 3;
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();  // initialize on load

    // Define allowed angle ranges (in degrees)
    const leftMinAngle = 135, leftMaxAngle = 225;
    const rightMinAngle = 315, rightMaxAngle = 405;

    // Initial frequencies and corresponding angles (map 400-480 Hz onto a 90° range)
    let leftFrequency, rightFrequency;
    // Default: left frequency = 440 Hz, right frequency = 445 Hz.
    let leftAngle = leftMaxAngle - ((440 - 400) / 80) * 90;   // 225 - 45 = 180°
    let rightAngle = rightMinAngle + ((445 - 400) / 80) * 90;  // 315 + ~50.6 ≈ 365.6°

    function updateFrequencies() {
      leftFrequency = 400 + ((leftMaxAngle - leftAngle) / 90) * 80;
      rightFrequency = 400 + ((rightAngle - rightMinAngle) / 90) * 80;
      if (audioStarted) {
        osc1.frequency.setValueAtTime(leftFrequency, audioCtx.currentTime);
        osc2.frequency.setValueAtTime(rightFrequency, audioCtx.currentTime);
      }
    }
    updateFrequencies();

    // Audio context and oscillators
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let osc1 = audioCtx.createOscillator();
    let osc2 = audioCtx.createOscillator();
    osc1.type = 'sine';
    osc2.type = 'sine';
    osc1.connect(audioCtx.destination);
    osc2.connect(audioCtx.destination);
    let audioStarted = false;

    // Variables for dragging
    let dragging = false;
    let dragHandle = null; // "left" or "right"

    // Utility: Convert degrees to radians
    function toRadians(deg) {
      return deg * Math.PI / 180;
    }

    // Get a point on the circle edge for a given angle (in degrees)
    function pointOnCircle(angleDeg) {
      const angleRad = toRadians(angleDeg);
      return {
        x: centerX + circleRadius * Math.cos(angleRad),
        y: centerY + circleRadius * Math.sin(angleRad)
      };
    }

    // Check if point is near a handle (within a threshold)
    function isNearHandle(mx, my, handlePos) {
      const dx = mx - handlePos.x;
      const dy = my - handlePos.y;
      return Math.sqrt(dx * dx + dy * dy) < 15;
    }

    // Mouse events for dragging handles
    canvas.addEventListener("mousedown", (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      if (!audioStarted) {
        osc1.start();
        osc2.start();
        audioStarted = true;
      }

      const leftPos = pointOnCircle(leftAngle);
      // Normalize right angle for display (if over 360, subtract 360)
      const rightDisplayAngle = rightAngle >= 360 ? rightAngle - 360 : rightAngle;
      const rightPos = pointOnCircle(rightDisplayAngle);

      if (isNearHandle(mx, my, leftPos)) {
        dragging = true;
        dragHandle = "left";
      } else if (isNearHandle(mx, my, rightPos)) {
        dragging = true;
        dragHandle = "right";
      }
    });

    canvas.addEventListener("mousemove", (e) => {
      if (!dragging) return;
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      let angle = Math.atan2(my - centerY, mx - centerX) * 180 / Math.PI;
      if (angle < 0) angle += 360;

      if (dragHandle === "left") {
        if (angle < leftMinAngle) angle = leftMinAngle;
        if (angle > leftMaxAngle) angle = leftMaxAngle;
        leftAngle = angle;
      } else if (dragHandle === "right") {
        let effectiveAngle = angle;
        if (effectiveAngle < rightMinAngle) effectiveAngle += 360;
        if (effectiveAngle < rightMinAngle) effectiveAngle = rightMinAngle;
        if (effectiveAngle > rightMaxAngle) effectiveAngle = rightMaxAngle;
        rightAngle = effectiveAngle;
      }
      updateFrequencies();
    });

    canvas.addEventListener("mouseup", () => {
      dragging = false;
      dragHandle = null;
    });
    canvas.addEventListener("mouseout", () => {
      dragging = false;
      dragHandle = null;
    });

    // Main drawing loop
    function draw() {
      // Draw dark blue background every frame
      ctx.fillStyle = "#00008B";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw the central white circle
      ctx.beginPath();
      ctx.arc(centerX, centerY, circleRadius, 0, Math.PI * 2);
      ctx.fillStyle = "#ffffff";
      ctx.fill();
      ctx.closePath();

      // Draw white circle border
      ctx.beginPath();
      ctx.arc(centerX, centerY, circleRadius, 0, Math.PI * 2);
      ctx.lineWidth = 4;
      ctx.strokeStyle = "#ffffff";
      ctx.stroke();
      ctx.closePath();

      // Draw the left slider's green arc along the edge (from current leftAngle to leftMaxAngle)
      ctx.beginPath();
      ctx.lineWidth = 6;
      ctx.strokeStyle = "#00FF00";
      ctx.arc(centerX, centerY, circleRadius, toRadians(leftAngle), toRadians(leftMaxAngle));
      ctx.stroke();
      ctx.closePath();

      // Draw the right slider's green arc along the edge (from rightMinAngle to current rightAngle)
      const drawRightMin = toRadians(rightMinAngle);
      const drawRightAngle = toRadians(rightAngle >= 360 ? rightAngle - 360 : rightAngle);
      ctx.beginPath();
      ctx.lineWidth = 6;
      ctx.strokeStyle = "#00FF00";
      ctx.arc(centerX, centerY, circleRadius, drawRightMin, drawRightAngle);
      ctx.stroke();
      ctx.closePath();

      // Draw left handle
      const leftHandle = pointOnCircle(leftAngle);
      ctx.beginPath();
      ctx.arc(leftHandle.x, leftHandle.y, 10, 0, Math.PI * 2);
      ctx.fillStyle = (dragHandle === "left") ? "#00FF00" : "#ffffff";
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "#00FF00";
      ctx.stroke();
      ctx.closePath();

      // Draw right handle
      const rightDisplayAngle = rightAngle >= 360 ? rightAngle - 360 : rightAngle;
      const rightHandle = pointOnCircle(rightDisplayAngle);
      ctx.beginPath();
      ctx.arc(rightHandle.x, rightHandle.y, 10, 0, Math.PI * 2);
      ctx.fillStyle = (dragHandle === "right") ? "#00FF00" : "#ffffff";
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "#00FF00";
      ctx.stroke();
      ctx.closePath();

      // Draw frequency values in the center of the circle
      ctx.fillStyle = "#000000";
      ctx.font = "bold 20px Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      const beatFrequency = Math.abs(leftFrequency - rightFrequency).toFixed(1);
      const lines = [
        "Freq1: " + leftFrequency.toFixed(1) + " Hz",
        "Freq2: " + rightFrequency.toFixed(1) + " Hz",
        "Beat: " + beatFrequency + " Hz"
      ];
      // Adjust vertical position to center the multi-line text
      lines.forEach((line, index) => {
        ctx.fillText(line, centerX, centerY - 30 + index * 25);
      });

      requestAnimationFrame(draw);
    }
    draw();
  </script>
</body>
</html>
